import numpy as np


class MazeEnv:
    """Environment for maze navigation."""

    def __init__(self, size_x: int, size_y: int, size_view: int):
        self.maze = create_maze(size_x, size_y)
        self.size_x = size_x
        self.size_y = size_y
        self.size_view = size_view
        self.size_view_half = (size_view - 1) // 2

        # Possible actions: up, down, left, right
        self.directions = np.array([[-1, 0], [1, 0], [0, -1], [0, 1]])

        # Start and goal positions
        self.start_pos = [(self.size_y + 1) // 2 - 1, 1]  # start position: left top corner
        self.goal_pos = [(self.size_y + 1) // 2 - 1, self.size_x - 1]
        self.reset()

    def reset(self) -> tuple[list[int], np.ndarray]:
        self.pos = self.start_pos.copy()
        return self.pos, self._get_obs()

    def step(self, action: int) -> tuple[list[int], np.ndarray, float, bool]:
        """Execute one step in the environment.

        Args:
            action: Integer {0, 1, 2, 3} for up, down, left, right

        Returns:
            position: New position [y, x]
            observation: Agent's view of the maze
            reward: Negative risk value (-1.0 to 0.0)
            done: Whether goal is reached
        """
        prev_x = self.pos[1]

        # Execute action
        y, x = self.pos
        if action is not None:
            dy, dx = self.directions[action]
            # Move 2 steps in the direction of the action if the path is clear
            # In a maze generated by create_maze.py,
            # if the agent is in a odd coordinate, passages are guaranteed to be at least 2 cells long
            # so checking the first cell (y + dy, x + dx) is sufficient to see if the path is clear
            if self.maze[y + dy, x + dx] == 0:
                y, x = y + dy * 2, x + dx * 2

        self.pos = [y, min(x, self.size_x - 1)]

        # Compute risk
        if self.pos[1] > prev_x:
            risk = 0.0  # Moving right (good)
        elif self.pos[1] < prev_x:
            risk = 1.0  # Moving left (bad)
        else:
            risk = 0.5  # No horizontal movement

        done = self.pos == self.goal_pos
        return self.pos, self._get_obs(), risk, done

    def _get_obs(self) -> np.ndarray:
        y, x = self.pos

        # Get view boundaries
        y_min = max(y - self.size_view_half, 0)
        y_max = min(y + self.size_view_half, self.size_y - 1)
        x_min = max(x - self.size_view_half, 0)
        x_max = min(x + self.size_view_half, self.size_x - 1)
        view = self.maze[y_min : y_max + 1, x_min : x_max + 1]

        # Center the view
        y_offset = max(self.size_view_half - y, 0)
        x_offset = max(self.size_view_half - x, 0)
        o_mat = np.ones((self.size_view, self.size_view), dtype=np.int32)
        o_mat[y_offset : y_offset + view.shape[0], x_offset : x_offset + view.shape[1]] = view

        return o_mat


def create_maze(
    size_x: int,
    size_y: int,
) -> np.ndarray:
    maze = np.zeros((size_y, size_x), dtype=np.int32)

    # set borders
    maze[[0, -1], :] = 1
    maze[:, [0, -1]] = 1

    # set goal
    maze[(size_y + 1) // 2 - 1, -1] = 0

    # set obstacles
    # create a grid of fixed obstacles
    maze[2:-2:2, 2:-2:2] = 1
    # add random walls around fixed obstacles
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # up, down, left, right
    for y in range(2, size_y - 2, 2):
        for x in range(2, size_x - 2, 2):
            while True:
                dy, dx = directions[np.random.randint(4)]
                y_new, x_new = y + dy, x + dx
                if maze[y_new, x_new] == 0:
                    maze[y_new, x_new] = 1
                    break

    return maze


def process_risks(
    step_risks: np.ndarray,
    chunk_size: int,
    delta_thresholds: list[float] = [-10.0, 0.0, 10.0],
    risk_values: list[float] = [0.55, 0.55, 0.45, 0],
) -> np.ndarray:
    """Process step-wise risks into chunk-based risk assessments.

    Args:
        step_risks: Array of step-wise risk values
        chunk_size: Size of chunks to process
        delta_thresholds: Thresholds for progress evaluation
        risk_values: Risk values to assign based on progress

    Returns:
        Array of processed risk values per chunk
    """
    chunk_risks = []
    for i in range(0, len(step_risks) - 1, chunk_size):
        # Average risk over chunk
        chunk_mean_risk = step_risks[i : i + chunk_size].mean()
        # Convert to progress measure (-chunk_size to +chunk_size)
        delta = (1 - chunk_mean_risk * 2) * chunk_size

        # Assign risk level based on progress
        if delta <= delta_thresholds[0]:
            risk = risk_values[0]
        elif delta <= delta_thresholds[1]:
            risk = risk_values[1]
        elif delta <= delta_thresholds[2]:
            risk = risk_values[2]
        else:
            risk = risk_values[3]
        chunk_risks.append(risk)

    return np.array(chunk_risks, dtype=np.float32)
